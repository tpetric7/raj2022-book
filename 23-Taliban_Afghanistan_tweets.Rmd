# Taliban in Afghanistan

Ein brisantes politisches Thema. Was passiert in Afghanistan nach dem Abzug der NATO-Truppen und der Machtübernahme der Taliban?

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(tidytext)
library(rtweet)
```


## Fetch Stream

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
library(tidyverse)
library(rtweet)

## Stream keywords used to filter tweets
q <- "Afghanistan"
## Stream for 30 minutes
streamtime <- 60
## Filename to save json data (backup)
filename <- "data/afghanistan2.json"

```


```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
## Stream tweets
stream_afghan <- stream_tweets(q = q, 
                               timeout = streamtime, 
                               file_name = filename, 
                               parse = FALSE)
```


```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
afghan_stream <- rtweet::parse_stream("data/afghanistan2.json")
writexl::write_xlsx(afghan_stream, "data/afghan_stream.xlsx")
```


## Fetch tweets

```{r eval=FALSE, include=TRUE}
library(tidyverse)
library(rtweet)

q <- "Afghanistan"
tweets_afghanistan_de <- search_tweets(q = q, 
                        n = 18000,
                        token = bearer_token(), 
                        include_rts = FALSE,
                        `-filter` = "replies",
                        lang = "de")

tweets_afghanistan_de
```


```{r eval=FALSE, include=TRUE}
q <- "Afghanistan"
tweets_afghanistan_en <- search_tweets(q = q, 
                        n = 18000,
                        token = bearer_token(), 
                        include_rts = FALSE,
                        `-filter` = "replies",
                        lang = "en")

tweets_afghanistan_en
```


```{r eval=FALSE, include=TRUE}
q <- "Afganistan"
tweets_afghanistan_sl <- search_tweets(q = q, 
                        n = 18000,
                        token = bearer_token(), 
                        include_rts = FALSE,
                        `-filter` = "replies",
                        lang = "sl")

tweets_afghanistan_sl
```


## Gather tweets

```{r eval=FALSE, include=TRUE}
tweets_afghanistan <- bind_rows(tweets_afghanistan_sl,
                                tweets_afghanistan_de,
                                tweets_afghanistan_en)
```

## Save tweets

```{r eval=FALSE, include=TRUE}
library(writexl)
write_xlsx(tweets_afghanistan, "data/tweets_afghanistan.xlsx")
write_rds(tweets_afghanistan, "data/tweets_afghanistan.rds")
```

## Load tweets

```{r message=FALSE, warning=FALSE}
tweets_afghanistan <- read_rds("data/tweets_afghanistan.rds")

tweets_afghanistan_de <- subset(tweets_afghanistan, lang == "de")
tweets_afghanistan_en <- subset(tweets_afghanistan, lang == "en")
tweets_afghanistan_sl <- subset(tweets_afghanistan, lang == "sl")

```


## Who wrote about

```{r message=FALSE, warning=FALSE}
tweets_afghanistan %>% 
  filter(str_detect(screen_name, "spiegel")) %>% 
  DT::datatable(fillContainer = TRUE, filter = "top",
                options = list(pageLength = 4))
```


```{r message=FALSE, warning=FALSE}
tweets_afghanistan %>% 
  filter(str_detect(screen_name, "Tonin")) %>% 
    DT::datatable(fillContainer = TRUE, filter = "top",
                options = list(pageLength = 4))
```


```{r message=FALSE, warning=FALSE}
tweets_afghanistan %>% 
  filter(str_detect(screen_name, "SpletnaMladina")) %>% 
      DT::datatable(fillContainer = TRUE, filter = "top",
                options = list(pageLength = 4))
```


```{r message=FALSE, warning=FALSE}
tweets_afghanistan %>% 
  filter(str_detect(screen_name, "Dnevnik")) %>% 
      DT::datatable(fillContainer = TRUE, filter = "top",
                options = list(pageLength = 4))
```


```{r message=FALSE, warning=FALSE}
tweets_afghanistan %>% 
  filter((screen_name == "Delo")) %>% 
      DT::datatable(fillContainer = TRUE, filter = "top",
                options = list(pageLength = 4))
```


```{r message=FALSE, warning=FALSE}
tweets_afghanistan %>% 
  filter(str_detect(screen_name, "Demokracija")) %>% 
      DT::datatable(fillContainer = TRUE, filter = "top",
                options = list(pageLength = 4))
```

## Timeplot

```{r message=FALSE, warning=FALSE}
## plot time series of tweets
p1 <- ts_plot(tweets_afghanistan, "3 hours", color = "red") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(face = "bold")) +
  ggplot2::labs(
    x = NULL, y = NULL,
    title = "Frequency of #Afghanistan Twitter statuses from past 9 days",
    subtitle = "Twitter status (tweet) counts aggregated using three-hour intervals",
    caption = "\nSource: Data collected from Twitter's REST API via rtweet"
  )

library(plotly)
ggplotly(p1)
```


```{r message=FALSE, warning=FALSE}
## plot time series of tweets
p2 <- ts_plot(tweets_afghanistan_de, "3 hours", 
              color = "darkgreen") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(face = "bold")) +
  ggplot2::labs(
    x = NULL, y = NULL,
    title = "Frequency of #rollingstones Twitter statuses from past 9 days",
    subtitle = "Twitter status (tweet) counts aggregated using three-hour intervals",
    caption = "\nSource: Data collected from Twitter's REST API via rtweet"
  )

library(plotly)
ggplotly(p2)

```


```{r message=FALSE, warning=FALSE}
## plot time series of tweets
p3 <- ts_plot(tweets_afghanistan_sl, "3 hours", 
              color = "darkgreen") +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(face = "bold")) +
  ggplot2::labs(
    x = NULL, y = NULL,
    title = "Frequency of #rollingstones Twitter statuses from past 9 days",
    subtitle = "Twitter status (tweet) counts aggregated using three-hour intervals",
    caption = "\nSource: Data collected from Twitter's REST API via rtweet"
  )

library(plotly)
ggplotly(p3)

```

## Reactable table

```{r message=FALSE, warning=FALSE}
tweet_table_data <- select(tweets_afghanistan_sl, -user_id, -status_id)

```

```{r message=FALSE, warning=FALSE}
library(reactable)
reactable(tweet_table_data, 
          filterable = TRUE, searchable = TRUE, bordered = TRUE, 
          striped = TRUE, highlight = TRUE,
          defaultPageSize = 25, showPageSizeOptions = TRUE, 
          showSortable = TRUE, pageSizeOptions = c(25, 50, 75, 100, 200), defaultSortOrder = "desc",
            columns = list(
            created_at = colDef(defaultSortOrder = "asc"),
            screen_name = colDef(defaultSortOrder = "asc"),
            text = colDef(html = TRUE, minWidth = 190, resizable = TRUE),
            favorite_count = colDef(filterable = FALSE),
            retweet_count = colDef(filterable =  FALSE),
            urls_expanded_url = colDef(html = TRUE)
          )
) 

```

Configure your reactable data table 

In the code chunk above, the filterable = TRUE argument added search filters below each column header, and searchable added the overall table search box at the top right. Turning on bordered, striped, and highlight does what you might expect: Adds a table border, adds alternating-row color “stripes,” and highlights a row if you put a cursor on it.

I set my defaultPageSize to 25. The showPageSizeOptions argument lets me change the page length interactively, and then I define page size options that will show up in a drop-down menu below the table (not visible in the screen shot). The showSortable argument adds little arrow icons next to column names so users know they can click to sort. And I set each column’s defaultSortOrder to descending instead of ascending. So if I click on the column of number of retweets or likes, I will see that as most to least, not least to most.

Finally, there is the columns argument. That’s a list containing a column definition for each column. Look at the reactable help files for more details on other available options. In this example, I set the created_at and screen_name columns to have a default sort order of ascending. For the text column, I set it to display HTML as HTML so I can add clickable links. I also set a minimum column width of 190 pixels and made the column resizable — so users can click and drag to make it wider or narrower.

I also turned off the filter boxes for favorite_count and reply_count. That’s because, unfortunately, reactable filters don’t understand when columns are numbers and will filter them as character strings. While reactable sorts number columns properly, the filter boxes are problematic. That’s the major drawback to reactable vs. the DT package: DT understands column types and filters accordingly. But sorting numerically is enough for me for this purpose. 

You can check out the video at the top of this article to see what it looks like when you sort a column or make the tweet text column wider and narrower.


Make your data table more useful

A couple of things will make this table more useful. This code doesn’t display images or videos included in tweets. That’s fine, because my purpose here is to scan text, not re-create a Twitter application. But that means it will sometimes be helpful to see the original tweet in order to view photos, videos, or comments.

I think it’s convenient to add a small clickable something at the end of each tweet’s text that you can click to see the actual tweet on Twitter. I decided on >> although it could be any character or characters.

To construct a URL, I need to know the format of a tweet, which if you look at any tweet on the Twitter website, you can see is https://twitter.com/username/status/tweetID. 

Using the glue package, that would be rendered like this: 

```{r message=FALSE, warning=FALSE}
library(glue)
#glue::glue("https://twitter.com/{screen_name}/status/{status_id}")

```

My full code to create a column with a clickable link to the tweet after the tweet text:

```{r}
#Tweet = glue::glue("{text} <a href='https://twitter.com/{screen_name}/status/{status_id}'>>> </a>")

```

And the code to create a data frame for an interactive table:

```{r message=FALSE, warning=FALSE}
tweet_table_data <- tweets_afghanistan_sl %>%
  select(user_id, status_id, created_at, screen_name, text, favorite_count, retweet_count, urls_expanded_url) %>%
  mutate(
    Tweet = glue::glue("{text} <a href='https://twitter.com/{screen_name}/status/{status_id}'>>> </a>") 
    )%>%
  select(DateTime = created_at, User = screen_name, Tweet, Likes = favorite_count, RTs = retweet_count, URLs = urls_expanded_url)

```

I'd also like to make clickable links from the URL column, which is now just text. This is a bit complicated, because the URL column is a list column because some tweets include more than one URL.

I’m sure there is a more elegant way to create clickable links from a list column of plain-text URLs, but the code below works. First I create a function to generate the HTML if there are no URLs, one URL, or two or more:

```{r message=FALSE, warning=FALSE}
make_url_html <- function(url) {
  if(length(url) < 2) {
    if(!is.na(url)) {
      as.character(glue("<a title = {url} target = '_new' href = '{url}'>{url}</a>") )
    } else {
      ""
    }
  } else {
    paste0(purrr::map_chr(url, ~ paste0("<a title = '", .x, "' target = '_new' href = '", .x, "'>", .x, "</a>", collapse = ", ")), collapse = ", ")
  }
}

```

I run purrr::map_chr() on the URL value if there are two or more URLs so that each URL gets its own HTML; then I paste them together and collapse them into a single character string to appear in the table.

Once my function works, I use purrr::map_chr() again to iterate over each item in the column:

```{r message=FALSE, warning=FALSE}
tweet_table_data$URLs <- purrr::map_chr(tweet_table_data$URLs, make_url_html)

```

Don’t worry if you don’t understand this part, since it’s really more about purrr and list columns than rtweet and reactable. And it’s not necessary to search and sort the tweets; you can always click to the original tweet and see clickable links there.

Finally, I can run my customized reactable() code on the new tweet table data: 

```{r message=FALSE, warning=FALSE}
reactable(tweet_table_data, 
          filterable = TRUE, searchable = TRUE, bordered = TRUE, striped = TRUE, highlight = TRUE,
          showSortable = TRUE, defaultSortOrder = "desc", defaultPageSize = 25, showPageSizeOptions = TRUE, pageSizeOptions = c(25, 50, 75, 100, 200), 
          columns = list(
            DateTime = colDef(defaultSortOrder = "asc"),
            User = colDef(defaultSortOrder = "asc"),
            Tweet = colDef(html = TRUE, minWidth = 190, resizable = TRUE),
            Likes = colDef(filterable = FALSE, format = colFormat(separators = TRUE)),
            RTs = colDef(filterable =  FALSE, format = colFormat(separators = TRUE)),
            URLs = colDef(html = TRUE)
          )
) 

```

If you’ve been following along, you should have your own interactive table that can search, sort, and filter conference or topic tweets.


